<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÉ –ú–∞–Ω—ñ–∫—é—Ä –Ω–∞ –ì–µ–ª–ª–æ–≤—ñ–Ω!</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÉ</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }
    body {
      background: #0f0c29;
      background: linear-gradient(to right, #24243e, #302b63, #0f0c29);
      overflow: hidden;
      font-family: 'Arial', 'Comic Sans MS', cursive, sans-serif;
      color: white;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    #video {
      z-index: 5;
      background: black;
    }
    #canvas {
      z-index: 10;
      background: transparent;
    }

    #langBtn {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      border: 2px solid white;
      color: white;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      font-weight: bold;
      transition: transform 0.2s;
    }
    #langBtn:hover {
      transform: scale(1.1);
    }

    #soundBtn {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(5px);
      border: 2px solid white;
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: transform 0.2s;
    }
    #soundBtn:hover {
      transform: scale(1.1);
    }

    #modeControls {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
    }
    .mode-btn {
      padding: 8px 16px;
      border-radius: 20px;
      background: #ff6b6b;
      color: white;
      border: none;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: transform 0.2s;
    }
    .mode-btn:hover {
      transform: scale(1.05);
    }
    .mode-btn.active {
      background: #ff4757;
      animation: pulse 1.5s infinite;
    }

    #designPicker {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      gap: 14px;
      z-index: 100;
      overflow-x: auto;
      white-space: nowrap;
      padding: 0 20px;
      box-sizing: border-box;
      scrollbar-width: thin;
      scrollbar-color: #ff4757 transparent;
    }
    .design-btn {
      width: 64px;
      height: 64px;
      border-radius: 18px;
      border: 3px solid white;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
      background: white;
      cursor: pointer;
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    .design-btn:hover, .design-btn.selected {
      transform: scale(1.1);
      box-shadow: 0 0 0 4px gold;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0.7); }
      70% { box-shadow: 0 0 0 12px rgba(255, 71, 87, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 71, 87, 0); }
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: orange;
      font-size: 20px;
      text-align: center;
      padding: 20px;
    }
    #loading p {
      margin-top: 20px;
      color: white;
      font-size: 16px;
    }

    #errorRetry {
      margin-top: 20px;
      padding: 10px 20px;
      background: #ff4757;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      border-radius: 10px;
    }

    #cameraIndicator, #handIndicator {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: lime;
      z-index: 100;
      display: none;
    }
    #handIndicator {
      top: 100px;
      color: white;
    }

    #tipOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
      color: white;
      font-size: 18px;
      z-index: 99;
      display: none;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="loading">
    üéÉ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ì–µ–ª–ª–æ–≤—ñ–Ω—Å—å–∫–æ–≥–æ –º–∞–Ω—ñ–∫—é—Ä—É...
    <p>–ù–∞–¥–∞–π—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏, –∫–æ–ª–∏ –∑'—è–≤–∏—Ç—å—Å—è –∑–∞–ø–∏—Ç</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="langBtn" aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏ –º–æ–≤—É">UK</div>
  <div id="soundBtn" aria-label="–£–≤—ñ–º–∫–Ω—É—Ç–∏/–≤–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫">üîä</div>

  <div id="modeControls">
    <button class="mode-btn active" id="applyAllBtn" aria-label="–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –¥–æ –≤—Å—ñ—Ö –ø–∞–ª—å—Ü—ñ–≤">üíÖ –£—Å—ñ –ø–∞–ª—å—Ü—ñ</button>
    <button class="mode-btn" id="selectFingerBtn" aria-label="–û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å">üëÜ –û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å</button>
  </div>

  <div id="designPicker"></div>
  <div id="cameraIndicator">üìπ –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞</div>
  <div id="handIndicator">‚úã –†—É–∫–∞ –Ω–µ –≤–∏—è–≤–ª–µ–Ω–∞</div>
  <div id="tipOverlay">–¢—Ä–∏–º–∞–π—Ç–µ —Ä—É–∫—É —Ç–∞–∫, —â–æ–± –±—É–ª–æ –≤–∏–¥–Ω–æ –≤–∞—à—ñ –Ω—ñ–≥—Ç—ñ</div>

  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    const FINGER_INDICES = {
      thumb: { tip: 4, dip: 3, pip: 2, mcp: 1 },
      index: { tip: 8, dip: 7, pip: 6, mcp: 5 },
      middle: { tip: 12, dip: 11, pip: 10, mcp: 9 },
      ring: { tip: 16, dip: 15, pip: 14, mcp: 13 },
      pinky: { tip: 20, dip: 19, pip: 18, mcp: 17 }
    };
    const FINGER_KEYS = ['thumb', 'index', 'middle', 'ring', 'pinky'];

    const translations = {
      en: {
        title: "üéÉ Halloween Nail Try-On!",
        loading: "üéÉ Loading Halloween Nail Try-On...",
        cameraPrompt: "Please allow camera access when prompted",
        allFingers: "üíÖ All Fingers",
        pickFinger: "üëÜ Pick Finger",
        cameraError: "‚ùå Could not access camera.<br>Try Chrome or Safari.",
        arError: "‚ùå AR failed to load.<br>Refresh the page.",
        retry: "Retry",
        cameraIndicator: "üìπ Camera Active",
        rearCamera: "üìπ Rear Camera Active",
        frontCamera: "üìπ Front Camera Active",
        handNotDetected: "‚úã Hand not detected"
      },
      uk: {
        title: "üéÉ –ú–∞–Ω—ñ–∫—é—Ä –Ω–∞ –ì–µ–ª–ª–æ–≤—ñ–Ω!",
        loading: "üéÉ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ì–µ–ª–ª–æ–≤—ñ–Ω—Å—å–∫–æ–≥–æ –º–∞–Ω—ñ–∫—é—Ä—É...",
        cameraPrompt: "–ù–∞–¥–∞–π—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏, –∫–æ–ª–∏ –∑'—è–≤–∏—Ç—å—Å—è –∑–∞–ø–∏—Ç",
        allFingers: "üíÖ –£—Å—ñ –ø–∞–ª—å—Ü—ñ",
        pickFinger: "üëÜ –û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å",
        cameraError: "‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏.<br>–°–ø—Ä–æ–±—É–π—Ç–µ —É Chrome –∞–±–æ Safari.",
        arError: "‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è AR.<br>–°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.",
        retry: "–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏",
        cameraIndicator: "üìπ –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        rearCamera: "üìπ –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        frontCamera: "üìπ –ü–µ—Ä–µ–¥–Ω—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        handNotDetected: "‚úã –†—É–∫–∞ –Ω–µ –≤–∏—è–≤–ª–µ–Ω–∞"
      }
    };

    let currentLang = localStorage.getItem('lang') || 'uk';
    if (!['en', 'uk'].includes(currentLang)) currentLang = 'uk';
    document.documentElement.lang = currentLang;
    document.title = translations[currentLang].title;

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const loading = document.getElementById("loading");
    const langBtn = document.getElementById("langBtn");
    const soundBtn = document.getElementById("soundBtn");
    const applyAllBtn = document.getElementById("applyAllBtn");
    const selectFingerBtn = document.getElementById("selectFingerBtn");
    const designPicker = document.getElementById("designPicker");
    const cameraIndicator = document.getElementById("cameraIndicator");
    const handIndicator = document.getElementById("handIndicator");
    const tipOverlay = document.getElementById("tipOverlay");

    function updateTexts(isRearCamera = true) {
      document.title = translations[currentLang].title;
      langBtn.textContent = currentLang.toUpperCase();
      langBtn.setAttribute('aria-label', currentLang === 'en' ? 'Switch to Ukrainian' : '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏ –Ω–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É');
      
      loading.innerHTML = `
        üéÉ ${translations[currentLang].loading}
        <p>${translations[currentLang].cameraPrompt}</p>
      `;
      
      applyAllBtn.textContent = translations[currentLang].allFingers;
      selectFingerBtn.textContent = translations[currentLang].pickFinger;
      cameraIndicator.textContent = isRearCamera ? translations[currentLang].rearCamera : translations[currentLang].frontCamera;
      handIndicator.textContent = translations[currentLang].handNotDetected;
    }

    langBtn.onclick = () => {
      currentLang = currentLang === 'en' ? 'uk' : 'en';
      localStorage.setItem('lang', currentLang);
      document.documentElement.lang = currentLang;
      updateTexts(video.srcObject?.getVideoTracks()[0]?.getCapabilities().facingMode === 'environment');
    };

    const DESIGNS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
    let currentDesign = "1";
    let nailImages = {};
    let isApplyAll = true;
    let selectedFingerIndex = -1;
    let isMuted = false;
    let bgAudio, clickAudio;
    let lastLandmarks = null;
    let smoothedLandmarks = null;
    const SMOOTHING_FACTOR = 0.7;
    let needsRedraw = true;

    function initAudio() {
      bgAudio = new Audio("audio/bg-music.mp3");
      clickAudio = new Audio("audio/click.mp3");
      bgAudio.loop = true;
      bgAudio.volume = 0.3;
      clickAudio.volume = 0.6;
      if (!isMuted) bgAudio.play().catch(e => console.log("Audio autoplay blocked:", e));

      document.addEventListener('visibilitychange', () => {
        if (document.hidden && !isMuted) {
          bgAudio.pause();
        } else if (!document.hidden && !isMuted) {
          bgAudio.play().catch(() => {});
        }
      });
    }

    async function loadDesigns() {
      loading.innerHTML += '<p>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∏–∑–∞–π–Ω—ñ–≤...</p>';
      const promises = DESIGNS.map(name => new Promise((resolve, reject) => {
        const img = new Image();
        img.src = `nails/halloween/${name}.png`;
        img.onload = () => resolve({ name, img });
        img.onerror = () => reject(new Error(`Failed to load image: nails/halloween/${name}.png`));
      }));
      try {
        const loaded = await Promise.all(promises);
        nailImages = Object.fromEntries(loaded.map(({ name, img }) => [name, img]));
      } catch (e) {
        console.error(e);
        loading.innerHTML = `${translations[currentLang].arError}<br><button id="errorRetry">${translations[currentLang].retry}</button>`;
        document.getElementById('errorRetry').onclick = () => location.reload();
        throw e;
      }
    }

    function buildDesignUI() {
      designPicker.innerHTML = "";
      DESIGNS.forEach(name => {
        const btn = document.createElement("img");
        btn.loading = "lazy";
        btn.src = `nails/halloween/${name}.png`;
        btn.className = "design-btn";
        btn.alt = `–î–∏–∑–∞–π–Ω –Ω—ñ–≥—Ç—ñ–≤ ${name}`;
        if (name === currentDesign) btn.classList.add("selected");
        btn.onclick = () => {
          currentDesign = name;
          document.querySelectorAll(".design-btn").forEach(b => b.classList.remove("selected"));
          btn.classList.add("selected");
          needsRedraw = true;
          if (!isMuted) {
            clickAudio.currentTime = 0;
            clickAudio.play().catch(() => {});
          }
        };
        designPicker.appendChild(btn);
      });
    }

    applyAllBtn.onclick = () => {
      isApplyAll = true;
      selectedFingerIndex = -1;
      applyAllBtn.classList.add("active");
      selectFingerBtn.classList.remove("active");
      needsRedraw = true;
    };
    
    selectFingerBtn.onclick = () => {
      isApplyAll = false;
      applyAllBtn.classList.remove("active");
      selectFingerBtn.classList.add("active");
      needsRedraw = true;
    };

    soundBtn.onclick = () => {
      isMuted = !isMuted;
      soundBtn.textContent = isMuted ? "üîá" : "üéµ";
      soundBtn.setAttribute('aria-label', isMuted ? '–£–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫' : '–í–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫');
      if (isMuted) {
        bgAudio.pause();
      } else {
        bgAudio.play().catch(() => {});
      }
    };

    async function getUserMediaWrapper(facingMode) {
      return navigator.mediaDevices.getUserMedia({
        video: { 
          facingMode: facingMode,
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      });
    }

    async function setupCamera() {
      try {
        const stream = await getUserMediaWrapper("environment");
        video.srcObject = stream;
        cameraIndicator.style.display = 'block';
        const isRear = stream.getVideoTracks()[0].getCapabilities().facingMode === 'environment';
        updateTexts(isRear);
        return new Promise(resolve => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });
      } catch (e) {
        try {
          const stream = await getUserMediaWrapper("user");
          video.srcObject = stream;
          cameraIndicator.style.display = 'block';
          updateTexts(false);
          return new Promise(resolve => {
            video.onloadedmetadata = () => {
              video.play();
              resolve();
            };
          });
        } catch (fallbackError) {
          loading.innerHTML = `${translations[currentLang].cameraError}<br><button id="errorRetry">${translations[currentLang].retry}</button>`;
          document.getElementById('errorRetry').onclick = setupCamera;
          console.error("Camera error:", fallbackError);
          throw fallbackError;
        }
      }
    }

    function smoothLandmarks(newLandmarks) {
      if (!smoothedLandmarks) {
        smoothedLandmarks = newLandmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z }));
        return smoothedLandmarks;
      }
      for (let i = 0; i < newLandmarks.length; i++) {
        smoothedLandmarks[i].x = smoothedLandmarks[i].x * (1 - SMOOTHING_FACTOR) + newLandmarks[i].x * SMOOTHING_FACTOR;
        smoothedLandmarks[i].y = smoothedLandmarks[i].y * (1 - SMOOTHING_FACTOR) + newLandmarks[i].y * SMOOTHING_FACTOR;
        smoothedLandmarks[i].z = smoothedLandmarks[i].z * (1 - SMOOTHING_FACTOR) + newLandmarks[i].z * SMOOTHING_FACTOR;
      }
      return smoothedLandmarks;
    }

    function getClosestFinger(touchX, touchY, landmarks) {
      let minDist = Infinity;
      let closestIndex = -1;
      
      FINGER_KEYS.forEach((key, i) => {
        const lm = landmarks[FINGER_INDICES[key].tip];
        const xLm = lm.x * canvas.width;
        const yLm = lm.y * canvas.height;
        const dist = Math.hypot(touchX - xLm, touchY - yLm);
        
        if (dist < minDist && dist < canvas.width * 0.1) {
          minDist = dist;
          closestIndex = i;
        }
      });
      return closestIndex;
    }

    canvas.addEventListener("touchstart", e => {
      if (isApplyAll || !lastLandmarks) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      selectedFingerIndex = getClosestFinger(x, y, lastLandmarks);
      needsRedraw = true;
    });

    function calculateNailSize(landmarks, fingerKey) {
      const indices = FINGER_INDICES[fingerKey];
      const tip = landmarks[indices.tip];
      const pip = landmarks[indices.pip];
      const dist = Math.hypot((tip.x - pip.x) * canvas.width, (tip.y - pip.y) * canvas.height);
      return Math.max(30, dist * 1.5);
    }

    function calculateNailAngle(landmarks, fingerKey) {
      const indices = FINGER_INDICES[fingerKey];
      const dip = landmarks[indices.dip];
      const pip = landmarks[indices.pip];
      return Math.atan2(dip.y - pip.y, dip.x - pip.x) * 180 / Math.PI;
    }

    function calculateNailCurve(landmarks, fingerKey) {
      const indices = FINGER_INDICES[fingerKey];
      const tip = landmarks[indices.tip];
      const dip = landmarks[indices.dip];
      const pip = landmarks[indices.pip];
      const curveHeight = Math.abs((tip.y - pip.y) * canvas.height) * 0.3; // –Ü–º—ñ—Ç–∞—Ü—ñ—è –≤–∏–≥–∏–Ω—É
      return curveHeight;
    }

    function renderAR(landmarks) {
      if (!needsRedraw) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();

      const img = nailImages[currentDesign];
      
      if (!img || !img.complete) return;

      FINGER_KEYS.forEach((key, i) => {
        if (!isApplyAll && i !== selectedFingerIndex) return;
        
        const indices = FINGER_INDICES[key];
        const lm = landmarks[indices.tip];
        const x = lm.x * canvas.width;
        const y = lm.y * canvas.height;

        const size = calculateNailSize(landmarks, key);
        const angle = calculateNailAngle(landmarks, key);
        const curveHeight = calculateNailCurve(landmarks, key);

        // –Ü–º—ñ—Ç–∞—Ü—ñ—è –∫—Ä–∏–≤–∏–∑–Ω–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—ó
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * Math.PI / 180);
        ctx.transform(1, -curveHeight / size * 0.5, 0, 1, 0, 0); // –ó—Å—É–≤–∞—î–º–æ –≤–µ—Ä—Ö–Ω—ñ —Ç–æ—á–∫–∏ –≤–≥–æ—Ä—É
        ctx.drawImage(img, -size / 2, -size * 0.6, size, size / 2);
        ctx.restore();

        // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –æ–±—Ä–∞–Ω–æ–≥–æ –ø–∞–ª—å—Ü—è
        if (!isApplyAll && i === selectedFingerIndex) {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle * Math.PI / 180);
          ctx.beginPath();
          ctx.ellipse(0, -size * 0.3, size / 2 + 2, size / 3 + 2, 0, 0, 2 * Math.PI);
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.restore();
        }
      });

      ctx.restore();
      needsRedraw = false;
    }

    let handLandmarker;
    async function init() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });

        await setupCamera();
        
        function updateCanvasSize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          video.style.width = '100%';
          video.style.height = '100%';
          needsRedraw = true;
        }

        let resizeTimeout;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(updateCanvasSize, 100);
        });
        updateCanvasSize();

        await loadDesigns();
        buildDesignUI();
        initAudio();
        updateTexts();

        loading.style.display = "none";

        let lastVideoTime = -1;
        
        const predict = (metadata) => {
          if (handLandmarker && video.readyState >= 2) {
            const currentTime = performance.now();
            
            if (currentTime - lastVideoTime > 100) {
              const predictions = handLandmarker.detectForVideo(video, currentTime);
              
              if (predictions.landmarks && predictions.landmarks.length > 0) {
                lastLandmarks = smoothLandmarks(predictions.landmarks[0]);
                handIndicator.style.display = 'none';
                tipOverlay.style.display = 'none';
                renderAR(lastLandmarks);
              } else {
                handIndicator.style.display = 'block';
                tipOverlay.style.display = 'block';
                if (needsRedraw) {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  needsRedraw = false;
                }
              }
              
              lastVideoTime = currentTime;
            }
          }
          if (video.requestVideoFrameCallback) {
            video.requestVideoFrameCallback(predict);
          } else {
            requestAnimationFrame(predict);
          }
        };
        
        if (video.requestVideoFrameCallback) {
          video.requestVideoFrameCallback(predict);
        } else {
          requestAnimationFrame(predict);
        }

        window.addEventListener("beforeunload", () => {
          if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop());
          }
          if (handLandmarker) {
            handLandmarker.close();
          }
          cameraIndicator.style.display = 'none';
        });
      } catch (e) {
        console.error("Initialization error:", e);
        loading.innerHTML = `${translations[currentLang].arError}<br><button id="errorRetry">${translations[currentLang].retry}</button>`;
        document.getElementById('errorRetry').onclick = () => location.reload();
      }
    }

    window.addEventListener("load", init);
  </script>
</body>
</html>
