<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Halloween Nail AR Try-On</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>Halloween</text></svg>">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: #0f0c29;
      background: linear-gradient(135deg, #24243e, #302b63, #0f0c29);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: white;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video {
      z-index: 1;
      display: none;
    }
    #canvas {
      z-index: 2;
      display: none;
    }

    /* Control Buttons */
    .control-btn {
      position: fixed;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }

    .control-btn:hover {
      transform: scale(1.15);
      background: rgba(255, 255, 255, 0.25);
    }

    #langBtn {
      top: 20px;
      right: 20px;
      font-weight: bold;
      font-size: 16px;
    }

    #soundBtn {
      top: 20px;
      left: 20px;
    }

    /* Mode Controls */
    #modeControls {
      position: fixed;
      top: 90px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(20px);
      padding: 8px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .mode-btn {
      padding: 10px 20px;
      border-radius: 20px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .mode-btn:hover {
      transform: translateY(-2px);
    }

    .mode-btn.active {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      animation: pulse 2s infinite;
    }

    /* Design Picker */
    #designPicker {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(20px);
      padding: 15px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      max-width: 90vw;
      overflow-x: auto;
      scrollbar-width: none;
    }

    #designPicker::-webkit-scrollbar {
      display: none;
    }

    .design-btn {
      width: 70px;
      height: 70px;
      border-radius: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      background: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
      object-fit: cover;
    }

    .design-btn:hover {
      transform: scale(1.1);
      border-color: rgba(255, 255, 255, 0.6);
    }

    .design-btn.selected {
      transform: scale(1.15);
      border-color: #ffd700;
      box-shadow: 0 0 0 3px #ffd700;
    }

    /* Loading & Indicators */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0f0c29, #302b63);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #ff9d00;
      font-size: clamp(18px, 4vw, 24px);
      text-align: center;
      padding: 20px;
      gap: 20px;
    }

    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 157, 0, 0.3);
      border-top: 4px solid #ff9d00;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    #loading p {
      color: #fff;
      font-size: clamp(14px, 3vw, 18px);
      max-width: 300px;
      line-height: 1.4;
    }

    .indicator {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 99;
      font-size: 14px;
    }

    #cameraIndicator {
      top: 20px;
    }

    #handIndicator {
      top: 160px;
    }

    .indicator.show {
      display: flex;
      animation: slideDown 0.3s ease;
    }

    #errorRetry {
      margin-top: 20px;
      padding: 12px 24px;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      border: none;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 25px;
      transition: all 0.3s ease;
    }

    #errorRetry:hover {
      transform: translateY(-2px);
    }

    /* Animations */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* Mobile Optimizations */
    @media (max-width: 768px) {
      .control-btn {
        width: 45px;
        height: 45px;
        font-size: 18px;
      }

      #modeControls {
        top: 80px;
      }

      .design-btn {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div id="loadingText">Loading Halloween Nail AR Experience...</div>
    <p>Please allow camera access when prompted</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <button id="langBtn" class="control-btn" aria-label="Switch language">EN</button>
  <button id="soundBtn" class="control-btn" aria-label="Toggle sound">Sound On</button>

  <div id="modeControls">
    <button class="mode-btn active" id="applyAllBtn" aria-label="Apply to all fingers">All Fingers</button>
    <button class="mode-btn" id="selectFingerBtn" aria-label="Select finger">Select Finger</button>
  </div>

  <div id="designPicker"></div>

  <div id="cameraIndicator" class="indicator">
    <span>Camera</span>
    <span>Camera Active</span>
  </div>

  <div id="handIndicator" class="indicator">
    <span>Hand</span>
    <span>Show your hand to the camera</span>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    // ОНОВЛЕНА КОНФІГУРАЦІЯ: короткі + вужчі нігті
    const CONFIG = {
      SMOOTHING_FACTOR: 0.7,
      HAND_NOT_DETECTED_THRESHOLD: 10,
      
      // Розмір нігтів (довжина підходить — не чіпаємо)
      NAIL_SCALE_FACTORS: {
        thumb: 0.5,
        index: 0.6,
        middle: 0.65,
        ring: 0.55,
        pinky: 0.4
      },
      
      // ВУЖЧІ НІГТІ — зменшені aspect ratios
      NAIL_ASPECT_RATIOS: {
        thumb: 0.7,   // було 0.9 → вужчий
        index: 0.6,   // було 0.8
        middle: 0.6,
        ring: 0.6,
        pinky: 0.55   // найвужчий
      },
      
      NAIL_OFFSETS: {
        thumb: { x: -0.01, y: -0.02 },
        index: { x: 0, y: -0.02 },
        middle: { x: 0, y: -0.025 },
        ring: { x: 0, y: -0.02 },
        pinky: { x: 0.005, y: -0.015 }
      },
      
      MAX_SIZES: {
        thumb: 60,
        index: 80,
        middle: 80,
        ring: 70,
        pinky: 50
      },
      
      MIN_SIZE: 20,
      MAX_SIZE: 100,
      
      WRIST_DISTANCE_REF: 0.08,
      SCALE_SENSITIVITY: 2.5,
      MAX_SCALE_FACTOR: 3.0,
      MIN_SCALE_FACTOR: 0.3
    };

    const FINGER_INDICES = {
      thumb: { tip: 4, mcp: 2, pip: 3, ip: 3 },
      index: { tip: 8, mcp: 5, pip: 6, dip: 7 },
      middle: { tip: 12, mcp: 9, pip: 10, dip: 11 },
      ring: { tip: 16, mcp: 13, pip: 14, dip: 15 },
      pinky: { tip: 20, mcp: 17, pip: 18, dip: 19 }
    };
    const FINGER_KEYS = Object.keys(FINGER_INDICES);

    const translations = {
      en: {
        title: "Halloween Nail AR Try-On",
        loading: "Loading Halloween Nail AR Experience...",
        cameraPrompt: "Please allow camera access when prompted",
        allFingers: "All Fingers",
        pickFinger: "Select Finger",
        cameraError: "Could not access camera.<br>Try Chrome or Safari.",
        arError: "AR failed to load.<br>Refresh the page.",
        retry: "Retry",
        cameraActive: "Camera Active",
        handNotDetected: "Show your hand to the camera"
      },
      uk: {
        title: "Манікюр на Гелловін!",
        loading: "Завантаження Гелловінського манікюру...",
        cameraPrompt: "Надайте доступ до камери, коли з'явиться запит",
        allFingers: "Усі пальці",
        pickFinger: "Обрати палець",
        cameraError: "Не вдалося отримати доступ до камери.<br>Спробуйте у Chrome або Safari.",
        arError: "Помилка завантаження AR.<br>Спробуйте оновити сторінку.",
        retry: "Повторити",
        cameraActive: "Камера активна",
        handNotDetected: "Наведіть руку в камеру"
      }
    };

    const state = {
      currentLang: 'en',
      currentDesign: "1",
      isApplyAll: true,
      selectedFingerIndex: -1,
      isMuted: true,
      lastLandmarks: null,
      smoothedLandmarks: null,
      handNotDetectedCount: 0,
      animationFrameId: null,
      palmOrientation: { x: 0, y: 0 },
      currentHandSize: 1.0,
      wristDistance: 0
    };

    const elements = {
      video: document.getElementById("video"),
      canvas: document.getElementById("canvas"),
      loading: document.getElementById("loading"),
      loadingText: document.getElementById("loadingText"),
      langBtn: document.getElementById("langBtn"),
      soundBtn: document.getElementById("soundBtn"),
      applyAllBtn: document.getElementById("applyAllBtn"),
      selectFingerBtn: document.getElementById("selectFingerBtn"),
      designPicker: document.getElementById("designPicker"),
      cameraIndicator: document.getElementById("cameraIndicator"),
      liquidIndicator: document.getElementById("handIndicator")
    };

    const audio = { bg: new Audio(), click: new Audio(), isLoaded: false };
    const DESIGNS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
    const nailTextures = {};
    let scene, camera, renderer, handLandmarker;
    const nails = {};

    class NailARApplication {
      constructor() { this.init(); }

      async init() {
        try {
          this.setupEventListeners();
          await this.setupCamera();
          await this.initWebGL();
          await this.setupHandTracking();
          await this.loadResources();
          this.setupAudio();
          this.updateUI();
          this.hideLoading();
          this.startRenderLoop();
        } catch (error) { this.handleError(error); }
      }

      setupEventListeners() {
        elements.langBtn.addEventListener('click', () => this.toggleLanguage());
        elements.soundBtn.addEventListener('click', () => this.toggleSound());
        elements.applyAllBtn.addEventListener('click', () => this.setApplyAllMode());
        elements.selectFingerBtn.addEventListener('click', () => this.setSelectFingerMode());
        elements.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        elements.canvas.addEventListener('touchstart', (e) => this.handleCanvasClick(e));
        window.addEventListener('resize', () => this.handleResize());
        window.addEventListener('beforeunload', () => this.cleanup());
      }

      async setupCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } }
        });
        elements.video.srcObject = stream;
        await new Promise(r => elements.video.onloadedmetadata = () => { elements.video.play(); r(); });
        this.showCameraIndicator();
      }

      async initWebGL() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-innerWidth/2, innerWidth/2, innerHeight/2, -innerHeight/2, 0.1, 1000);
        camera.position.z = 10;

        renderer = new THREE.WebGLRenderer({ canvas: elements.canvas, alpha: true, antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        this.createNails();
      }

      createNails() {
        FINGER_KEYS.forEach(key => {
          const geo = new THREE.PlaneGeometry(1, CONFIG.NAIL_ASPECT_RATIOS[key]);
          const mat = new THREE.MeshBasicMaterial({ transparent: true, side: THREE.DoubleSide, depthTest: false, depthWrite: false });
          const nail = new THREE.Mesh(geo, mat);
          nail.visible = false;
          nail.frustumCulled = false;
          nail.userData.fingerType = key;
          nails[key] = nail;
          scene.add(nail);
        });
      }

      async setupHandTracking() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      async loadResources() {
        await this.loadDesigns();
        this.buildDesignUI();
      }

      async loadDesigns() {
        const load = name => new Promise(res => {
          const img = new Image();
          img.src = `nails/halloween/${name}.png`;
          img.onload = () => {
            const tex = new THREE.CanvasTexture(img);
            tex.minFilter = tex.magFilter = THREE.LinearFilter;
            nailTextures[name] = tex;
            res();
          };
          img.onerror = () => {
            const c = document.createElement('canvas'); c.width = c.height = 100;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#FF6B6B'; ctx.fillRect(0,0,100,100);
            ctx.fillStyle = 'white'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
            ctx.fillText(name, 50, 55);
            nailTextures[name] = new THREE.CanvasTexture(c);
            res();
          };
        });
        await Promise.all(DESIGNS.map(load));
      }

      buildDesignUI() {
        elements.designPicker.innerHTML = '';
        DESIGNS.forEach(name => {
          const btn = document.createElement('img');
          btn.src = `nails/halloween/${name}.png`;
          btn.className = `design-btn ${name === state.currentDesign ? 'selected' : ''}`;
          btn.loading = 'lazy';
          btn.onclick = () => { this.selectDesign(name); this.playSound(audio.click); };
          elements.designPicker.appendChild(btn);
        });
      }

      setupAudio() {
        audio.bg.loop = true; audio.bg.volume = 0.3;
        audio.click.volume = 0.6;
        audio.bg.src = 'audio/bg-music.mp3';
        audio.click.src = 'audio/click.mp3';
      }

      playSound(s) { if (!state.isMuted) s.currentTime = 0, s.play().catch(() => {}); }
      toggleSound() { state.isMuted = !state.isMuted; state.isMuted ? audio.bg.pause() : this.playBackgroundMusic(); this.updateSoundButton(); this.playSound(audio.click); }
      playBackgroundMusic() { if (!state.isMuted) audio.bg.play().catch(() => {}); }

      startRenderLoop() {
        const render = () => {
          this.detectHands();
          this.renderAR();
          state.animationFrameId = requestAnimationFrame(render);
        };
        render();
      }

      detectHands() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        const preds = handLandmarker.detectForVideo(elements.video, performance.now());
        if (preds.landmarks?.length) {
          state.handNotDetectedCount = 0;
          this.hideHandIndicator();
          const lm = preds.landmarks[0];
          state.lastLandmarks = this.smoothLandmarks(lm);
          this.calculateHandSize(lm);
        } else {
          if (++state.handNotDetectedCount > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
            this.showHandIndicator();
            this.hideAllNails();
          }
        }
      }

      calculateHandSize(lm) {
        const d = Math.hypot(lm[0].x - lm[1].x, lm[0].y - lm[1].y);
        state.wristDistance = d;
        let scale = d / CONFIG.WRIST_DISTANCE_REF * CONFIG.SCALE_SENSITIVITY;
        scale = Math.min(scale, CONFIG.MAX_SCALE_FACTOR);
        scale = Math.max(scale, CONFIG.MIN_SCALE_FACTOR);
        state.currentHandSize = scale;
      }

      smoothLandmarks(newLm) {
        if (!state.smoothedLandmarks) return state.smoothedLandmarks = newLm.map(p => ({...p}));
        newLm.forEach((p, i) => {
          state.smoothedLandmarks[i].x = this.lerp(state.smoothedLandmarks[i].x, p.x, CONFIG.SMOOTHING_FACTOR);
          state.smoothedLandmarks[i].y = this.lerp(state.smoothedLandmarks[i].y, p.y, CONFIG.SMOOTHING_FACTOR);
        });
        return state.smoothedLandmarks;
      }

      lerp(a, b, t) { return a * (1 - t) + b * t; }

      renderAR() {
        if (!state.lastLandmarks) return;
        FINGER_KEYS.forEach((key, i) => {
          const nail = nails[key];
          if (!state.isApplyAll && i !== state.selectedFingerIndex) { nail.visible = false; return; }
          this.updateNailPosition(key);
          nail.visible = true;
        });
        renderer.render(scene, camera);
      }

      updateNailPosition(key) {
        const lm = state.lastLandmarks;
        const nail = nails[key];
        key === 'thumb' ? this.updateThumbNailPosition(key, lm) : this.updateFingerNailPosition(key, lm);
        if (nailTextures[state.currentDesign]) nail.material.map = nailTextures[state.currentDesign], nail.material.needsUpdate = true;
      }

      updateThumbNailPosition(key, lm) {
        const { tip, mcp, ip } = FINGER_INDICES[key];
        const tipL = lm[tip], mcpL = lm[mcp], ipL = lm[ip];
        const offset = CONFIG.NAIL_OFFSETS[key];
        const x = (tipL.x + offset.x) * innerWidth;
        const y = (1 - (tipL.y + offset.y)) * innerHeight;
        const len = Math.hypot((tipL.x - mcpL.x) * innerWidth, (tipL.y - mcpL.y) * innerHeight);
        let size = len * CONFIG.NAIL_SCALE_FACTORS[key] * state.currentHandSize;
        size = Math.min(size, CONFIG.MAX_SIZE);
        size = Math.max(size, CONFIG.MIN_SIZE);
        const angle = Math.atan2(tipL.y - ipL.y, tipL.x - ipL.x);
        nails[key].position.set(x - innerWidth/2, y - innerHeight/2, 0);
        nails[key].scale.set(size, size * CONFIG.NAIL_ASPECT_RATIOS[key], 1);
        nails[key].rotation.z = angle;
      }

      updateFingerNailPosition(key, lm) {
        const { tip, pip } = FINGER_INDICES[key];
        const tipL = lm[tip], pipL = lm[pip];
        const offset = CONFIG.NAIL_OFFSETS[key];
        const x = (tipL.x + offset.x) * innerWidth;
        const y = (1 - (tipL.y + offset.y)) * innerHeight;
        const len = Math.hypot((tipL.x - pipL.x) * innerWidth, (tipL.y - pipL.y) * innerHeight);
        let size = len * CONFIG.NAIL_SCALE_FACTORS[key] * state.currentHandSize;
        size = Math.min(size, CONFIG.MAX_SIZE);
        size = Math.max(size, CONFIG.MIN_SIZE);
        const angle = Math.atan2(tipL.y - pipL.y, tipL.x - pipL.x);
        nails[key].position.set(x - innerWidth/2, y - innerHeight/2, 0);
        nails[key].scale.set(size, size * CONFIG.NAIL_ASPECT_RATIOS[key], 1);
        nails[key].rotation.z = angle;
      }

      hideAllNails() { FINGER_KEYS.forEach(k => nails[k].visible = false); renderer.render(scene, camera); }

      handleCanvasClick(e) {
        if (state.isApplyAll || !state.lastLandmarks) return;
        e.preventDefault();
        const rect = elements.canvas.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        state.selectedFingerIndex = this.getClosestFinger(x, y);
        this.playSound(audio.click);
      }

      getClosestFinger(x, y) {
        let min = Infinity, idx = -1;
        FINGER_KEYS.forEach((k, i) => {
          const tip = FINGER_INDICES[k].tip;
          const px = state.lastLandmarks[tip].x * innerWidth;
          const py = state.lastLandmarks[tip].y * innerHeight;
          const d = Math.hypot(x - px, y - py);
          if (d < min && d < innerWidth * 0.1) { min = d; idx = i; }
        });
        return idx;
      }

      toggleLanguage() { state.currentLang = state.currentLang === 'en' ? 'uk' : 'en'; this.updateUI(); this.playSound(audio.click); }
      setApplyAllMode() { state.isApplyAll = true; state.selectedFingerIndex = -1; elements.applyAllBtn.classList.add('active'); elements.selectFingerBtn.classList.remove('active'); this.playSound(audio.click); }
      setSelectFingerMode() { state.isApplyAll = false; elements.applyAllBtn.classList.remove('active'); elements.selectFingerBtn.classList.add('active'); this.playSound(audio.click); }
      selectDesign(n) { state.currentDesign = n; document.querySelectorAll('.design-btn').forEach(b => b.classList.toggle('selected', b.src.includes(n+'.png'))); this.playSound(audio.click); }

      updateUI() {
        const t = translations[state.currentLang];
        document.title = t.title;
        elements.loadingText.textContent = t.loading;
        elements.applyAllBtn.textContent = t.allFingers;
        elements.selectFingerBtn.textContent = t.pickFinger;
        elements.handIndicator.innerHTML = `<span>Hand</span><span>${t.handNotDetected}</span>`;
        elements.langBtn.textContent = state.currentLang.toUpperCase();
        this.updateSoundButton();
      }

      updateSoundButton() { elements.soundBtn.textContent = state.isMuted ? 'Sound Off' : 'Sound On'; }

      showCameraIndicator() { elements.cameraIndicator.classList.add('show'); setTimeout(() => elements.cameraIndicator.classList.remove('show'), 3000); }
      showHandIndicator() { elements.handIndicator.classList.add('show'); }
      hideHandIndicator() { elements.handIndicator.classList.remove('show'); }
      hideLoading() { elements.loading.style.display = 'none'; elements.video.style.display = elements.canvas.style.display = 'block'; }

      handleResize() {
        camera.left = -innerWidth/2; camera.right = innerWidth/2;
        camera.top = innerHeight/2; camera.bottom = -innerHeight/2;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      }

      handleError(e) {
        const msg = e.message === 'CAMERA_ERROR' ? translations[state.currentLang].cameraError : translations[state.currentLang].arError;
        this.showError(msg);
      }

      showError(msg) {
        elements.loading.innerHTML = `<div style="color:#ff4757;font-size:24px;margin-bottom:20px;">Error</div><div style="color:white;font-size:18px;line-height:1.4;margin-bottom:20px;">${msg}</div><button id="errorRetry">${translations[state.currentLang].retry}</button>`;
        elements.loading.style.display = 'flex';
        document.getElementById('errorRetry').onclick = () => location.reload();
      }

      cleanup() {
        if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
        elements.video.srcObject?.getTracks().forEach(t => t.stop());
        handLandmarker?.close();
        audio.bg.pause();
      }
    }

    window.addEventListener('DOMContentLoaded', () => new NailARApplication());
  </script>
</body>
</html>
