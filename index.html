<script type="module">
  import * as THREE from 'three';
  import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

  const CONFIG = {
    SMOOTHING_FACTOR: 0.7,
    HAND_NOT_DETECTED_THRESHOLD: 10,

    // Масштабні коефіцієнти — впливають на ВИСОТУ нігтя
    NAIL_SCALE_FACTORS: {
      thumb: 0.42,
      index: 0.52,
      middle: 0.54,
      ring: 0.52,
      pinky: 0.40
    },

    // ВАЖЛИВО: це ШИРИНА / ВИСОТА (aspect ratio)
    NAIL_ASPECT_RATIOS: {
      thumb: 0.78,    // широкий
      index: 0.58,    // вузький
      middle: 0.58,   // вузький
      ring: 0.62,     // трохи ширший
      pinky: 0.70     // середній
    },

    NAIL_OFFSETS: {
      thumb: { x: -0.01, y: -0.02 },
      index: { x: 0, y: -0.02 },
      middle: { x: 0, y: -0.025 },
      ring: { x: 0, y: -0.02 },
      pinky: { x: 0.005, y: -0.015 }
    },

    MIN_SIZE: 25,
    MAX_SIZE: 85,

    WRIST_DISTANCE_REF: 0.1,
    SCALE_SENSITIVITY: 1.8,
    MAX_SCALE_FACTOR: 2.0,
    MIN_SCALE_FACTOR: 0.6
  };

  const FINGER_INDICES = {
    thumb: { tip: 4, mcp: 2, pip: 3, ip: 3 },
    index: { tip: 8, mcp: 5, pip: 6, dip: 7 },
    middle: { tip: 12, mcp: 9, pip: 10, dip: 11 },
    ring: { tip: 16, mcp: 13, pip: 14, dip: 15 },
    pinky: { tip: 20, mcp: 17, pip: 18, dip: 19 }
  };
  const FINGER_KEYS = Object.keys(FINGER_INDICES);

  const translations = {
    en: {
      title: "Halloween Nail AR Try-On",
      loading: "Loading Halloween Nail AR Experience...",
      cameraPrompt: "Please allow camera access when prompted",
      allFingers: "All Fingers",
      pickFinger: "Select Finger",
      cameraError: "Could not access camera.<br>Try Chrome or Safari.",
      arError: "AR failed to load.<br>Refresh the page.",
      retry: "Retry",
      cameraActive: "Camera Active",
      handNotDetected: "Show your hand to the camera"
    },
    uk: {
      title: "Манікюр на Гелловін!",
      loading: "Завантаження Гелловінського манікюру...",
      cameraPrompt: "Надайте доступ до камери, коли з'явиться запит",
      allFingers: "Усі пальці",
      pickFinger: "Обрати палець",
      cameraError: "Не вдалося отримати доступ до камери.<br>Спробуйте у Chrome або Safari.",
      arError: "Помилка завантаження AR.<br>Спробуйте оновити сторінку.",
      retry: "Повторити",
      cameraActive: "Камера активна",
      handNotDetected: "Наведіть руку в камеру"
    }
  };

  const state = {
    currentLang: 'en',
    currentDesign: "1",
    isApplyAll: true,
    selectedFingerIndex: -1,
    isMuted: true,
    lastLandmarks: null,
    smoothedLandmarks: null,
    handNotDetectedCount: 0,
    animationFrameId: null,
    palmOrientation: { x: 0, y: 0 },
    currentHandSize: 1.0,
    wristDistance: 0
  };

  const elements = {
    video: document.getElementById("video"),
    canvas: document.getElementById("canvas"),
    loading: document.getElementById("loading"),
    loadingText: document.getElementById("loadingText"),
    langBtn: document.getElementById("langBtn"),
    soundBtn: document.getElementById("soundBtn"),
    applyAllBtn: document.getElementById("applyAllBtn"),
    selectFingerBtn: document.getElementById("selectFingerBtn"),
    designPicker: document.getElementById("designPicker"),
    cameraIndicator: document.getElementById("cameraIndicator"),
    handIndicator: document.getElementById("handIndicator")
  };

  const audio = {
    bg: new Audio(),
    click: new Audio(),
    isLoaded: false
  };

  const DESIGNS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
  const nailTextures = {};

  let scene, camera, renderer;
  const nails = {};
  let handLandmarker;

  class NailARApplication {
    constructor() {
      this.init();
    }

    async init() {
      try {
        this.setupEventListeners();
        await this.setupCamera();
        await this.initWebGL();
        await this.setupHandTracking();
        await this.loadResources();
        this.setupAudio();
        this.updateUI();
        this.hideLoading();
        this.startRenderLoop();
      } catch (error) {
        this.handleError(error);
      }
    }

    setupEventListeners() {
      elements.langBtn.addEventListener('click', () => this.toggleLanguage());
      elements.soundBtn.addEventListener('click', () => this.toggleSound());
      elements.applyAllBtn.addEventListener('click', () => this.setApplyAllMode());
      elements.selectFingerBtn.addEventListener('click', () => this.setSelectFingerMode());

      elements.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
      elements.canvas.addEventListener('touchstart', (e) => this.handleCanvasClick(e));

      window.addEventListener('resize', () => this.handleResize());
      window.addEventListener('beforeunload', () => this.cleanup());
    }

    async setupCamera() {
      try {
        const constraints = {
          video: {
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30 }
          }
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        elements.video.srcObject = stream;

        await new Promise((resolve) => {
          elements.video.onloadedmetadata = () => {
            elements.video.play();
            resolve();
          };
        });

        this.showCameraIndicator();

      } catch (error) {
        console.error('Camera setup failed:', error);
        throw new Error('CAMERA_ERROR');
      }
    }

    async initWebGL() {
      scene = new THREE.Scene();

      camera = new THREE.OrthographicCamera(
        -window.innerWidth / 2,
        window.innerWidth / 2,
        window.innerHeight / 2,
        -window.innerHeight / 2,
        0.1,
        1000
      );
      camera.position.z = 10;

      renderer = new THREE.WebGLRenderer({
        canvas: elements.canvas,
        alpha: true,
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      this.createNails();
    }

    // ВИПРАВЛЕНО: Геометрія з правильним aspect ratio
    createNails() {
      FINGER_KEYS.forEach(key => {
        const aspect = CONFIG.NAIL_ASPECT_RATIOS[key];
        const nailGeometry = new THREE.PlaneGeometry(aspect, 1); // ширина = aspect, висота = 1

        const nailMaterial = new THREE.MeshBasicMaterial({
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: false,
          depthWrite: false
        });

        const nail = new THREE.Mesh(nailGeometry, nailMaterial);
        nail.visible = false;
        nail.frustumCulled = false;
        nail.userData.fingerType = key;
        nails[key] = nail;
        scene.add(nail);
      });
    }

    async setupHandTracking() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });
    }

    async loadResources() {
      await this.loadDesigns();
      this.buildDesignUI();
    }

    async loadDesigns() {
      const loadImage = (name) => new Promise((resolve) => {
        const img = new Image();
        img.src = `nails/halloween/${name}.png`;
        img.onload = () => {
          const texture = new THREE.CanvasTexture(img);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = false;
          nailTextures[name] = texture;
          resolve();
        };
        img.onerror = () => {
          console.warn(`Failed to load: ${name}.png, using fallback`);
          const canvas = document.createElement('canvas');
          canvas.width = 100;
          canvas.height = 100;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#FF6B6B';
          ctx.fillRect(0, 0, 100, 100);
          ctx.fillStyle = 'white';
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(name, 50, 55);

          const texture = new THREE.CanvasTexture(canvas);
          nailTextures[name] = texture;
          resolve();
        };
      });

      try {
        await Promise.all(DESIGNS.map(name => loadImage(name)));
        console.log('All designs loaded');
      } catch (error) {
        console.error('Design loading failed:', error);
        throw new Error('DESIGN_LOAD_ERROR');
      }
    }

    buildDesignUI() {
      elements.designPicker.innerHTML = '';

      DESIGNS.forEach(name => {
        const btn = document.createElement('img');
        btn.src = `nails/halloween/${name}.png`;
        btn.className = `design-btn ${name === state.currentDesign ? 'selected' : ''}`;
        btn.alt = `Design ${name}`;
        btn.loading = 'lazy';

        btn.addEventListener('click', () => {
          this.selectDesign(name);
          this.playSound(audio.click);
        });

        elements.designPicker.appendChild(btn);
      });
    }

    setupAudio() {
      audio.bg.loop = true;
      audio.bg.volume = 0.3;
      audio.click.volume = 0.6;

      audio.bg.src = 'audio/bg-music.mp3';
      audio.click.src = 'audio/click.mp3';

      audio.bg.onerror = () => console.log('BG music not available');
      audio.click.onerror = () => console.log('Click sound not available');
    }

    playSound(sound) {
      if (state.isMuted) return;

      try {
        sound.currentTime = 0;
        sound.play().catch(e => console.log('Sound play failed:', e));
      } catch (error) {
        console.warn('Error playing sound:', error);
      }
    }

    toggleSound() {
      state.isMuted = !state.isMuted;

      if (state.isMuted) {
        audio.bg.pause();
      } else {
        this.playBackgroundMusic();
      }

      this.updateSoundButton();
      this.playSound(audio.click);
    }

    playBackgroundMusic() {
      if (state.isMuted) return;

      audio.bg.play().catch(e => {
        console.log('Background music autoplay blocked');
      });
    }

    startRenderLoop() {
      const render = () => {
        this.detectHands();
        this.renderAR();
        state.animationFrameId = requestAnimationFrame(render);
      };
      render();
    }

    detectHands() {
      if (!handLandmarker || elements.video.readyState < 2) return;

      try {
        const predictions = handLandmarker.detectForVideo(elements.video, performance.now());

        if (predictions.landmarks?.length > 0) {
          state.handNotDetectedCount = 0;
          this.hideHandIndicator();

          const landmarks = predictions.landmarks[0];
          state.lastLandmarks = this.smoothLandmarks(landmarks);
          this.updatePalmOrientation(landmarks);
          this.calculateHandSize(landmarks);

        } else {
          state.handNotDetectedCount++;
          if (state.handNotDetectedCount > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
            this.showHandIndicator();
            this.hideAllNails();
          }
        }
      } catch (error) {
        console.error('Hand detection error:', error);
      }
    }

    calculateHandSize(landmarks) {
      const wristStart = landmarks[0];
      const wristEnd = landmarks[1];

      const wristDistance = Math.hypot(
        wristStart.x - wristEnd.x,
        wristStart.y - wristEnd.y
      );

      state.wristDistance = wristDistance;

      let scaleFactor = wristDistance / CONFIG.WRIST_DISTANCE_REF * CONFIG.SCALE_SENSITIVITY;
      scaleFactor = Math.min(scaleFactor, CONFIG.MAX_SCALE_FACTOR);
      scaleFactor = Math.max(scaleFactor, CONFIG.MIN_SCALE_FACTOR);

      state.currentHandSize = scaleFactor;
    }

    updatePalmOrientation(landmarks) {
      const wrist = landmarks[0];
      const middleMCP = landmarks[9];

      state.palmOrientation = {
        x: (middleMCP.x - wrist.x) * window.innerWidth,
        y: (middleMCP.y - wrist.y) * window.innerHeight
      };
    }

    smoothLandmarks(newLandmarks) {
      if (!state.smoothedLandmarks) {
        state.smoothedLandmarks = newLandmarks.map(lm => ({ ...lm }));
        return state.smoothedLandmarks;
      }

      for (let i = 0; i < newLandmarks.length; i++) {
        state.smoothedLandmarks[i].x = this.lerp(
          state.smoothedLandmarks[i].x,
          newLandmarks[i].x,
          CONFIG.SMOOTHING_FACTOR
        );
        state.smoothedLandmarks[i].y = this.lerp(
          state.smoothedLandmarks[i].y,
          newLandmarks[i].y,
          CONFIG.SMOOTHING_FACTOR
        );
      }

      return state.smoothedLandmarks;
    }

    lerp(start, end, factor) {
      return start * (1 - factor) + end * factor;
    }

    renderAR() {
      if (!state.lastLandmarks) return;

      FINGER_KEYS.forEach((key, index) => {
        const nail = nails[key];

        if (!state.isApplyAll && index !== state.selectedFingerIndex) {
          nail.visible = false;
          return;
        }

        this.updateNailPosition(key);
        nail.visible = true;
      });

      renderer.render(scene, camera);
    }

    updateNailPosition(fingerKey) {
      const landmarks = state.lastLandmarks;
      const nail = nails[fingerKey];

      if (fingerKey === 'thumb') {
        this.updateThumbNailPosition(fingerKey, landmarks);
      } else {
        this.updateFingerNailPosition(fingerKey, landmarks);
      }

      if (nailTextures[state.currentDesign]) {
        nail.material.map = nailTextures[state.currentDesign];
        nail.material.needsUpdate = true;
      }
    }

    // ВИПРАВЛЕНО: масштаб ТІЛЬКИ по висоті
    updateThumbNailPosition(fingerKey, landmarks) {
      const nail = nails[fingerKey];
      const { tip, mcp, ip } = FINGER_INDICES[fingerKey];
      const wrist = landmarks[0];

      const tipLandmark = landmarks[tip];
      const mcpLandmark = landmarks[mcp];
      const ipLandmark = landmarks[ip];

      const thumbDirection = this.calculateThumbDirection(tipLandmark, mcpLandmark, wrist);
      const thumbOffset = this.calculateThumbOffset(thumbDirection);

      const screenX = (tipLandmark.x + thumbOffset.x) * window.innerWidth;
      const screenY = (1 - (tipLandmark.y + thumbOffset.y)) * window.innerHeight;

      const thumbLength = Math.hypot(
        (tipLandmark.x - mcpLandmark.x) * window.innerWidth,
        (tipLandmark.y - mcpLandmark.y) * window.innerHeight
      );

      let nailHeight = thumbLength * CONFIG.NAIL_SCALE_FACTORS.thumb;
      nailHeight *= state.currentHandSize;
      nailHeight = Math.min(nailHeight, CONFIG.MAX_SIZE);
      nailHeight = Math.max(nailHeight, CONFIG.MIN_SIZE);

      const angle = Math.atan2(
        tipLandmark.y - ipLandmark.y,
        tipLandmark.x - ipLandmark.x
      );

      nail.position.set(
        screenX - window.innerWidth / 2,
        screenY - window.innerHeight / 2,
        0
      );

      nail.scale.set(nailHeight, nailHeight, 1); // геометрія вже має aspect
      nail.rotation.z = angle;
    }

    // ВИПРАВЛЕНО: вузькі нігті на вказівному, середньому, безіменному
    updateFingerNailPosition(fingerKey, landmarks) {
      const nail = nails[fingerKey];
      const { tip, pip } = FINGER_INDICES[fingerKey];

      const tipLandmark = landmarks[tip];
      const pipLandmark = landmarks[pip];

      const offset = CONFIG.NAIL_OFFSETS[fingerKey];
      const screenX = (tipLandmark.x + offset.x) * window.innerWidth;
      const screenY = (1 - (tipLandmark.y + offset.y)) * window.innerHeight;

      const fingerLength = Math.hypot(
        (tipLandmark.x - pipLandmark.x) * window.innerWidth,
        (tipLandmark.y - pipLandmark.y) * window.innerHeight
      );

      let nailHeight = fingerLength * CONFIG.NAIL_SCALE_FACTORS[fingerKey];
      nailHeight *= state.currentHandSize;
      nailHeight = Math.min(nailHeight, CONFIG.MAX_SIZE);
      nailHeight = Math.max(nailHeight, CONFIG.MIN_SIZE);

      const angle = Math.atan2(
        tipLandmark.y - pipLandmark.y,
        tipLandmark.x - pipLandmark.x
      );

      nail.position.set(
        screenX - window.innerWidth / 2,
        screenY - window.innerHeight / 2,
        0
      );

      nail.scale.set(nailHeight, nailHeight, 1); // aspect збережений
      nail.rotation.z = angle;
    }

    calculateThumbDirection(tip, mcp, wrist) {
      return {
        x: tip.x - wrist.x,
        y: tip.y - wrist.y
      };
    }

    calculateThumbOffset(thumbDirection) {
      const baseOffset = CONFIG.NAIL_OFFSETS.thumb;
      const magnitude = Math.hypot(thumbDirection.x, thumbDirection.y);
      const correctionFactor = Math.min(magnitude * 5, 0.02);

      return {
        x: baseOffset.x - correctionFactor,
        y: baseOffset.y - correctionFactor * 0.5
      };
    }

    hideAllNails() {
      FINGER_KEYS.forEach(key => {
        nails[key].visible = false;
      });
      renderer.render(scene, camera);
    }

    handleCanvasClick(event) {
      if (state.isApplyAll || !state.lastLandmarks) return;

      event.preventDefault();

      const rect = elements.canvas.getBoundingClientRect();
      const x = (event.clientX || event.touches[0].clientX) - rect.left;
      const y = (event.clientY || event.touches[0].clientY) - rect.top;

      state.selectedFingerIndex = this.getClosestFinger(x, y);
      this.playSound(audio.click);
    }

    getClosestFinger(touchX, touchY) {
      let minDist = Infinity;
      let closestIndex = -1;

      FINGER_KEYS.forEach((key, index) => {
        const tipIndex = FINGER_INDICES[key].tip;
        const landmark = state.lastLandmarks[tipIndex];

        const x = landmark.x * window.innerWidth;
        const y = landmark.y * window.innerHeight;
        const dist = Math.hypot(touchX - x, touchY - y);

        if (dist < minDist && dist < window.innerWidth * 0.1) {
          minDist = dist;
          closestIndex = index;
        }
      });

      return closestIndex;
    }

    toggleLanguage() {
      state.currentLang = state.currentLang === 'en' ? 'uk' : 'en';
      this.updateUI();
      this.playSound(audio.click);
    }

    setApplyAllMode() {
      state.isApplyAll = true;
      state.selectedFingerIndex = -1;
      elements.applyAllBtn.classList.add('active');
      elements.selectFingerBtn.classList.remove('active');
      this.playSound(audio.click);
    }

    setSelectFingerMode() {
      state.isApplyAll = false;
      elements.applyAllBtn.classList.remove('active');
      elements.selectFingerBtn.classList.add('active');
      this.playSound(audio.click);
    }

    selectDesign(name) {
      state.currentDesign = name;

      document.querySelectorAll('.design-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.src.includes(`${name}.png`));
      });

      this.playSound(audio.click);
    }

    updateUI() {
      const t = translations[state.currentLang];

      document.title = t.title;
      elements.loadingText.textContent = t.loading;
      elements.applyAllBtn.textContent = t.allFingers;
      elements.selectFingerBtn.textContent = t.pickFinger;
      elements.handIndicator.innerHTML = `<span>Hand</span><span>${t.handNotDetected}</span>`;

      elements.langBtn.textContent = state.currentLang === 'en' ? 'EN' : 'UK';
      this.updateSoundButton();
    }

    updateSoundButton() {
      elements.soundBtn.textContent = state.isMuted ? 'Muted' : 'Sound';
    }

    showCameraIndicator() {
      elements.cameraIndicator.classList.add('show');
      setTimeout(() => {
        elements.cameraIndicator.classList.remove('show');
      }, 3000);
    }

    showHandIndicator() {
      elements.handIndicator.classList.add('show');
    }

    hideHandIndicator() {
      elements.handIndicator.classList.remove('show');
    }

    hideLoading() {
      elements.loading.style.display = 'none';
      elements.video.style.display = 'block';
      elements.canvas.style.display = 'block';
    }

    handleResize() {
      if (!camera || !renderer) return;

      camera.left = -window.innerWidth / 2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = -window.innerHeight / 2;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    handleError(error) {
      console.error('App error:', error);

      let message = translations[state.currentLang].arError;
      if (error.message === 'CAMERA_ERROR') {
        message = translations[state.currentLang].cameraError;
      } else if (error.message === 'DESIGN_LOAD_ERROR') {
        message = translations[state.currentLang].arError;
      }

      this.showError(message);
    }

    showError(message) {
      elements.loading.innerHTML = `
        <div style="color: #ff4757; font-size: 24px; margin-bottom: 20px;">Error</div>
        <div style="color: white; font-size: 18px; margin-bottom: 20px; line-height: 1.4;">${message}</div>
        <button id="errorRetry">${translations[state.currentLang].retry}</button>
      `;
      elements.loading.style.display = 'flex';

      document.getElementById('errorRetry').addEventListener('click', () => {
        location.reload();
      });
    }

    cleanup() {
      if (state.animationFrameId) {
        cancelAnimationFrame(state.animationFrameId);
      }

      if (elements.video.srcObject) {
        elements.video.srcObject.getTracks().forEach(track => track.stop());
      }

      if (handLandmarker) {
        handLandmarker.close();
      }

      if (audio.bg) {
        audio.bg.pause();
      }
    }
  }

  window.addEventListener('DOMContentLoaded', () => {
    new NailARApplication();
  });
</script>
